package scalan.collection

import scalan._
import scala.reflect.runtime.universe._
import scala.reflect._

package impl {
// Abs -----------------------------------
trait ConcreteCostsDefs extends scalan.Scalan with ConcreteCosts {
  self: Library =>

  case class CostedPrimCtor[T]
      (override val value: Rep[T], override val cost: Rep[Long])
    extends CostedPrim[T](value, cost) with Def[CostedPrim[T]] {
    implicit lazy val eT = value.elem

    lazy val selfType = element[CostedPrim[T]]
  }
  // elem for concrete class
  class CostedPrimElem[T](val iso: Iso[CostedPrimData[T], CostedPrim[T]])(implicit override val eT: Elem[T])
    extends CostedElem[T, CostedPrim[T]]
    with ConcreteElem[CostedPrimData[T], CostedPrim[T]] {
    override lazy val parent: Option[Elem[_]] = Some(costedElement(element[T]))
    override def buildTypeArgs = super.buildTypeArgs ++ TypeArgs("T" -> (eT -> scalan.util.Invariant))
    override def convertCosted(x: Rep[Costed[T]]) = CostedPrim(x.value, x.cost)
    override def getDefaultRep = CostedPrim(element[T].defaultRepValue, 0l)
    override lazy val tag = {
      implicit val tagT = eT.tag
      weakTypeTag[CostedPrim[T]]
    }
  }

  // state representation type
  type CostedPrimData[T] = (T, Long)

  // 3) Iso for concrete class
  class CostedPrimIso[T](implicit eT: Elem[T])
    extends EntityIso[CostedPrimData[T], CostedPrim[T]] with Def[CostedPrimIso[T]] {
    override def from(p: Rep[CostedPrim[T]]) =
      (p.value, p.cost)
    override def to(p: Rep[(T, Long)]) = {
      val Pair(value, cost) = p
      CostedPrim(value, cost)
    }
    lazy val eFrom = pairElement(element[T], element[Long])
    lazy val eTo = new CostedPrimElem[T](self)
    lazy val selfType = new CostedPrimIsoElem[T](eT)
    def productArity = 1
    def productElement(n: Int) = eT
  }
  case class CostedPrimIsoElem[T](eT: Elem[T]) extends Elem[CostedPrimIso[T]] {
    def getDefaultRep = reifyObject(new CostedPrimIso[T]()(eT))
    lazy val tag = {
      implicit val tagT = eT.tag
      weakTypeTag[CostedPrimIso[T]]
    }
    override def buildTypeArgs = super.buildTypeArgs ++ TypeArgs("T" -> (eT -> scalan.util.Invariant))
  }
  // 4) constructor and deconstructor
  class CostedPrimCompanionCtor extends CompanionDef[CostedPrimCompanionCtor] with CostedPrimCompanion {
    def selfType = CostedPrimCompanionElem
    override def toString = "CostedPrimCompanion"
    @scalan.OverloadId("fromData")
    def apply[T](p: Rep[CostedPrimData[T]]): Rep[CostedPrim[T]] = {
      implicit val eT = p._1.elem
      isoCostedPrim[T].to(p)
    }

    @scalan.OverloadId("fromFields")
    def apply[T](value: Rep[T], cost: Rep[Long]): Rep[CostedPrim[T]] =
      mkCostedPrim(value, cost)

    def unapply[T](p: Rep[Costed[T]]) = unmkCostedPrim(p)
  }
  lazy val CostedPrimRep: Rep[CostedPrimCompanionCtor] = new CostedPrimCompanionCtor
  lazy val CostedPrim: CostedPrimCompanionCtor = proxyCostedPrimCompanion(CostedPrimRep)
  implicit def proxyCostedPrimCompanion(p: Rep[CostedPrimCompanionCtor]): CostedPrimCompanionCtor = {
    proxyOps[CostedPrimCompanionCtor](p)
  }

  implicit case object CostedPrimCompanionElem extends CompanionElem[CostedPrimCompanionCtor] {
    lazy val tag = weakTypeTag[CostedPrimCompanionCtor]
    protected def getDefaultRep = CostedPrimRep
  }

  implicit def proxyCostedPrim[T](p: Rep[CostedPrim[T]]): CostedPrim[T] =
    proxyOps[CostedPrim[T]](p)

  implicit class ExtendedCostedPrim[T](p: Rep[CostedPrim[T]]) {
    def toData: Rep[CostedPrimData[T]] = {
      implicit val eT = p.value.elem
      isoCostedPrim(eT).from(p)
    }
  }

  // 5) implicit resolution of Iso
  implicit def isoCostedPrim[T](implicit eT: Elem[T]): Iso[CostedPrimData[T], CostedPrim[T]] =
    reifyObject(new CostedPrimIso[T]()(eT))

  case class CostedPairCtor[L, R]
      (override val l: Rep[L], override val r: Rep[R], override val cost: Rep[Long])
    extends CostedPair[L, R](l, r, cost) with Def[CostedPair[L, R]] {
    implicit lazy val eL = l.elem;
implicit lazy val eR = r.elem
    override lazy val eT: Elem[(L, R)] = implicitly[Elem[(L, R)]]
    lazy val selfType = element[CostedPair[L, R]]
  }
  // elem for concrete class
  class CostedPairElem[L, R](val iso: Iso[CostedPairData[L, R], CostedPair[L, R]])(implicit val eL: Elem[L], val eR: Elem[R])
    extends CostedElem[(L, R), CostedPair[L, R]]
    with ConcreteElem[CostedPairData[L, R], CostedPair[L, R]] {
    override lazy val parent: Option[Elem[_]] = Some(costedElement(pairElement(element[L],element[R])))
    override def buildTypeArgs = super.buildTypeArgs ++ TypeArgs("L" -> (eL -> scalan.util.Invariant), "R" -> (eR -> scalan.util.Invariant))
    override def convertCosted(x: Rep[Costed[(L, R)]]) = // Converter is not generated by meta
!!!("Cannot convert from Costed to CostedPair: missing fields List(l, r)")
    override def getDefaultRep = CostedPair(element[L].defaultRepValue, element[R].defaultRepValue, 0l)
    override lazy val tag = {
      implicit val tagL = eL.tag
      implicit val tagR = eR.tag
      weakTypeTag[CostedPair[L, R]]
    }
  }

  // state representation type
  type CostedPairData[L, R] = (L, (R, Long))

  // 3) Iso for concrete class
  class CostedPairIso[L, R](implicit eL: Elem[L], eR: Elem[R])
    extends EntityIso[CostedPairData[L, R], CostedPair[L, R]] with Def[CostedPairIso[L, R]] {
    override def from(p: Rep[CostedPair[L, R]]) =
      (p.l, p.r, p.cost)
    override def to(p: Rep[(L, (R, Long))]) = {
      val Pair(l, Pair(r, cost)) = p
      CostedPair(l, r, cost)
    }
    lazy val eFrom = pairElement(element[L], pairElement(element[R], element[Long]))
    lazy val eTo = new CostedPairElem[L, R](self)
    lazy val selfType = new CostedPairIsoElem[L, R](eL, eR)
    def productArity = 2
    def productElement(n: Int) = n match {
      case 0 => eL
      case 1 => eR
    }
  }
  case class CostedPairIsoElem[L, R](eL: Elem[L], eR: Elem[R]) extends Elem[CostedPairIso[L, R]] {
    def getDefaultRep = reifyObject(new CostedPairIso[L, R]()(eL, eR))
    lazy val tag = {
      implicit val tagL = eL.tag
      implicit val tagR = eR.tag
      weakTypeTag[CostedPairIso[L, R]]
    }
    override def buildTypeArgs = super.buildTypeArgs ++ TypeArgs("L" -> (eL -> scalan.util.Invariant), "R" -> (eR -> scalan.util.Invariant))
  }
  // 4) constructor and deconstructor
  class CostedPairCompanionCtor extends CompanionDef[CostedPairCompanionCtor] with CostedPairCompanion {
    def selfType = CostedPairCompanionElem
    override def toString = "CostedPairCompanion"
    @scalan.OverloadId("fromData")
    def apply[L, R](p: Rep[CostedPairData[L, R]]): Rep[CostedPair[L, R]] = {
      implicit val eL = p._1.elem;
implicit val eR = p._2.elem
      isoCostedPair[L, R].to(p)
    }

    @scalan.OverloadId("fromFields")
    def apply[L, R](l: Rep[L], r: Rep[R], cost: Rep[Long]): Rep[CostedPair[L, R]] =
      mkCostedPair(l, r, cost)

    def unapply[L, R](p: Rep[Costed[(L, R)]]) = unmkCostedPair(p)
  }
  lazy val CostedPairRep: Rep[CostedPairCompanionCtor] = new CostedPairCompanionCtor
  lazy val CostedPair: CostedPairCompanionCtor = proxyCostedPairCompanion(CostedPairRep)
  implicit def proxyCostedPairCompanion(p: Rep[CostedPairCompanionCtor]): CostedPairCompanionCtor = {
    proxyOps[CostedPairCompanionCtor](p)
  }

  implicit case object CostedPairCompanionElem extends CompanionElem[CostedPairCompanionCtor] {
    lazy val tag = weakTypeTag[CostedPairCompanionCtor]
    protected def getDefaultRep = CostedPairRep
  }

  implicit def proxyCostedPair[L, R](p: Rep[CostedPair[L, R]]): CostedPair[L, R] =
    proxyOps[CostedPair[L, R]](p)

  implicit class ExtendedCostedPair[L, R](p: Rep[CostedPair[L, R]]) {
    def toData: Rep[CostedPairData[L, R]] = {
      implicit val eL = p.l.elem;
implicit val eR = p.r.elem
      isoCostedPair(eL, eR).from(p)
    }
  }

  // 5) implicit resolution of Iso
  implicit def isoCostedPair[L, R](implicit eL: Elem[L], eR: Elem[R]): Iso[CostedPairData[L, R], CostedPair[L, R]] =
    reifyObject(new CostedPairIso[L, R]()(eL, eR))

  case class CostedArrayCtor[T]
      (override val arr: Rep[Col[Costed[T]]])
    extends CostedArray[T](arr) with Def[CostedArray[T]] {
    implicit lazy val eT = arr.eA.typeArgs("T")._1.asElem[T]

    lazy val selfType = element[CostedArray[T]]
  }
  // elem for concrete class
  class CostedArrayElem[T](val iso: Iso[CostedArrayData[T], CostedArray[T]])(implicit override val eT: Elem[T])
    extends CostedElem[WArray[T], CostedArray[T]]
    with ConcreteElem[CostedArrayData[T], CostedArray[T]] {
    override lazy val parent: Option[Elem[_]] = Some(costedElement(wArrayElement(element[T])))
    override def buildTypeArgs = super.buildTypeArgs ++ TypeArgs("T" -> (eT -> scalan.util.Invariant))
    override def convertCosted(x: Rep[Costed[Array[T]]]) = // Converter is not generated by meta
!!!("Cannot convert from Costed to CostedArray: missing fields List(arr)")
    override def getDefaultRep = CostedArray(element[Col[Costed[T]]].defaultRepValue)
    override lazy val tag = {
      implicit val tagT = eT.tag
      weakTypeTag[CostedArray[T]]
    }
  }

  // state representation type
  type CostedArrayData[T] = Col[Costed[T]]

  // 3) Iso for concrete class
  class CostedArrayIso[T](implicit eT: Elem[T])
    extends EntityIso[CostedArrayData[T], CostedArray[T]] with Def[CostedArrayIso[T]] {
    override def from(p: Rep[CostedArray[T]]) =
      p.arr
    override def to(p: Rep[Col[Costed[T]]]) = {
      val arr = p
      CostedArray(arr)
    }
    lazy val eFrom = element[Col[Costed[T]]]
    lazy val eTo = new CostedArrayElem[T](self)
    lazy val selfType = new CostedArrayIsoElem[T](eT)
    def productArity = 1
    def productElement(n: Int) = eT
  }
  case class CostedArrayIsoElem[T](eT: Elem[T]) extends Elem[CostedArrayIso[T]] {
    def getDefaultRep = reifyObject(new CostedArrayIso[T]()(eT))
    lazy val tag = {
      implicit val tagT = eT.tag
      weakTypeTag[CostedArrayIso[T]]
    }
    override def buildTypeArgs = super.buildTypeArgs ++ TypeArgs("T" -> (eT -> scalan.util.Invariant))
  }
  // 4) constructor and deconstructor
  class CostedArrayCompanionCtor extends CompanionDef[CostedArrayCompanionCtor] with CostedArrayCompanion {
    def selfType = CostedArrayCompanionElem
    override def toString = "CostedArrayCompanion"

    @scalan.OverloadId("fromFields")
    def apply[T](arr: Rep[Col[Costed[T]]]): Rep[CostedArray[T]] =
      mkCostedArray(arr)

    def unapply[T](p: Rep[Costed[Array[T]]]) = unmkCostedArray(p)
  }
  lazy val CostedArrayRep: Rep[CostedArrayCompanionCtor] = new CostedArrayCompanionCtor
  lazy val CostedArray: CostedArrayCompanionCtor = proxyCostedArrayCompanion(CostedArrayRep)
  implicit def proxyCostedArrayCompanion(p: Rep[CostedArrayCompanionCtor]): CostedArrayCompanionCtor = {
    proxyOps[CostedArrayCompanionCtor](p)
  }

  implicit case object CostedArrayCompanionElem extends CompanionElem[CostedArrayCompanionCtor] {
    lazy val tag = weakTypeTag[CostedArrayCompanionCtor]
    protected def getDefaultRep = CostedArrayRep
  }

  implicit def proxyCostedArray[T](p: Rep[CostedArray[T]]): CostedArray[T] =
    proxyOps[CostedArray[T]](p)

  implicit class ExtendedCostedArray[T](p: Rep[CostedArray[T]]) {
    def toData: Rep[CostedArrayData[T]] = {
      implicit val eT = p.arr.eA.typeArgs("T")._1.asElem[T]
      isoCostedArray(eT).from(p)
    }
  }

  // 5) implicit resolution of Iso
  implicit def isoCostedArray[T](implicit eT: Elem[T]): Iso[CostedArrayData[T], CostedArray[T]] =
    reifyObject(new CostedArrayIso[T]()(eT))

  case class ConcreteCostedBuilderCtor
      ()
    extends ConcreteCostedBuilder() with Def[ConcreteCostedBuilder] {
    lazy val selfType = element[ConcreteCostedBuilder]
  }
  // elem for concrete class
  class ConcreteCostedBuilderElem(val iso: Iso[ConcreteCostedBuilderData, ConcreteCostedBuilder])
    extends CostedBuilderElem[ConcreteCostedBuilder]
    with ConcreteElem[ConcreteCostedBuilderData, ConcreteCostedBuilder] {
    override lazy val parent: Option[Elem[_]] = Some(costedBuilderElement)
    override def buildTypeArgs = super.buildTypeArgs ++ TypeArgs()
    override def convertCostedBuilder(x: Rep[CostedBuilder]) = ConcreteCostedBuilder()
    override def getDefaultRep = ConcreteCostedBuilder()
    override lazy val tag = {
      weakTypeTag[ConcreteCostedBuilder]
    }
  }

  // state representation type
  type ConcreteCostedBuilderData = Unit

  // 3) Iso for concrete class
  class ConcreteCostedBuilderIso
    extends EntityIso[ConcreteCostedBuilderData, ConcreteCostedBuilder] with Def[ConcreteCostedBuilderIso] {
    override def from(p: Rep[ConcreteCostedBuilder]) =
      ()
    override def to(p: Rep[Unit]) = {
      val unit = p
      ConcreteCostedBuilder()
    }
    lazy val eFrom = UnitElement
    lazy val eTo = new ConcreteCostedBuilderElem(self)
    lazy val selfType = new ConcreteCostedBuilderIsoElem
    def productArity = 0
    def productElement(n: Int) = ???
  }
  case class ConcreteCostedBuilderIsoElem() extends Elem[ConcreteCostedBuilderIso] {
    def getDefaultRep = reifyObject(new ConcreteCostedBuilderIso())
    lazy val tag = {
      weakTypeTag[ConcreteCostedBuilderIso]
    }
    override def buildTypeArgs = super.buildTypeArgs ++ TypeArgs()
  }
  // 4) constructor and deconstructor
  class ConcreteCostedBuilderCompanionCtor extends CompanionDef[ConcreteCostedBuilderCompanionCtor] with ConcreteCostedBuilderCompanion {
    def selfType = ConcreteCostedBuilderCompanionElem
    override def toString = "ConcreteCostedBuilderCompanion"
    @scalan.OverloadId("fromData")
    def apply(p: Rep[ConcreteCostedBuilderData]): Rep[ConcreteCostedBuilder] = {
      isoConcreteCostedBuilder.to(p)
    }

    @scalan.OverloadId("fromFields")
    def apply(): Rep[ConcreteCostedBuilder] =
      mkConcreteCostedBuilder()

    def unapply(p: Rep[CostedBuilder]) = unmkConcreteCostedBuilder(p)
  }
  lazy val ConcreteCostedBuilderRep: Rep[ConcreteCostedBuilderCompanionCtor] = new ConcreteCostedBuilderCompanionCtor
  lazy val ConcreteCostedBuilder: ConcreteCostedBuilderCompanionCtor = proxyConcreteCostedBuilderCompanion(ConcreteCostedBuilderRep)
  implicit def proxyConcreteCostedBuilderCompanion(p: Rep[ConcreteCostedBuilderCompanionCtor]): ConcreteCostedBuilderCompanionCtor = {
    proxyOps[ConcreteCostedBuilderCompanionCtor](p)
  }

  implicit case object ConcreteCostedBuilderCompanionElem extends CompanionElem[ConcreteCostedBuilderCompanionCtor] {
    lazy val tag = weakTypeTag[ConcreteCostedBuilderCompanionCtor]
    protected def getDefaultRep = ConcreteCostedBuilderRep
  }

  implicit def proxyConcreteCostedBuilder(p: Rep[ConcreteCostedBuilder]): ConcreteCostedBuilder =
    proxyOps[ConcreteCostedBuilder](p)

  implicit class ExtendedConcreteCostedBuilder(p: Rep[ConcreteCostedBuilder]) {
    def toData: Rep[ConcreteCostedBuilderData] = {
      isoConcreteCostedBuilder.from(p)
    }
  }

  // 5) implicit resolution of Iso
  implicit def isoConcreteCostedBuilder: Iso[ConcreteCostedBuilderData, ConcreteCostedBuilder] =
    reifyObject(new ConcreteCostedBuilderIso())

  registerModule(ConcreteCostsModule)

  object CostedPrimMethods {
    object builder {
      def unapply(d: Def[_]): Option[Rep[CostedPrim[T]] forSome {type T}] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[CostedPrimElem[_]] && method.getName == "builder" =>
          Some(receiver).asInstanceOf[Option[Rep[CostedPrim[T]] forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Sym): Option[Rep[CostedPrim[T]] forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }
  }

  object CostedPrimCompanionMethods {
  }

  def mkCostedPrim[T]
    (value: Rep[T], cost: Rep[Long]): Rep[CostedPrim[T]] = {
    new CostedPrimCtor[T](value, cost)
  }
  def unmkCostedPrim[T](p: Rep[Costed[T]]) = p.elem.asInstanceOf[Elem[_]] match {
    case _: CostedPrimElem[T] @unchecked =>
      Some((p.asRep[CostedPrim[T]].value, p.asRep[CostedPrim[T]].cost))
    case _ =>
      None
  }

  object CostedPairMethods {
    object builder {
      def unapply(d: Def[_]): Option[Rep[CostedPair[L, R]] forSome {type L; type R}] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[CostedPairElem[_, _]] && method.getName == "builder" =>
          Some(receiver).asInstanceOf[Option[Rep[CostedPair[L, R]] forSome {type L; type R}]]
        case _ => None
      }
      def unapply(exp: Sym): Option[Rep[CostedPair[L, R]] forSome {type L; type R}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object value {
      def unapply(d: Def[_]): Option[Rep[CostedPair[L, R]] forSome {type L; type R}] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[CostedPairElem[_, _]] && method.getName == "value" =>
          Some(receiver).asInstanceOf[Option[Rep[CostedPair[L, R]] forSome {type L; type R}]]
        case _ => None
      }
      def unapply(exp: Sym): Option[Rep[CostedPair[L, R]] forSome {type L; type R}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }
  }

  object CostedPairCompanionMethods {
  }

  def mkCostedPair[L, R]
    (l: Rep[L], r: Rep[R], cost: Rep[Long]): Rep[CostedPair[L, R]] = {
    new CostedPairCtor[L, R](l, r, cost)
  }
  def unmkCostedPair[L, R](p: Rep[Costed[(L, R)]]) = p.elem.asInstanceOf[Elem[_]] match {
    case _: CostedPairElem[L, R] @unchecked =>
      Some((p.asRep[CostedPair[L, R]].l, p.asRep[CostedPair[L, R]].r, p.asRep[CostedPair[L, R]].cost))
    case _ =>
      None
  }

  object CostedArrayMethods {
    object builder {
      def unapply(d: Def[_]): Option[Rep[CostedArray[T]] forSome {type T}] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[CostedArrayElem[_]] && method.getName == "builder" =>
          Some(receiver).asInstanceOf[Option[Rep[CostedArray[T]] forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Sym): Option[Rep[CostedArray[T]] forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object value {
      def unapply(d: Def[_]): Option[Rep[CostedArray[T]] forSome {type T}] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[CostedArrayElem[_]] && method.getName == "value" =>
          Some(receiver).asInstanceOf[Option[Rep[CostedArray[T]] forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Sym): Option[Rep[CostedArray[T]] forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object cost {
      def unapply(d: Def[_]): Option[Rep[CostedArray[T]] forSome {type T}] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[CostedArrayElem[_]] && method.getName == "cost" =>
          Some(receiver).asInstanceOf[Option[Rep[CostedArray[T]] forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Sym): Option[Rep[CostedArray[T]] forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }
  }

  object CostedArrayCompanionMethods {
  }

  def mkCostedArray[T]
    (arr: Rep[Col[Costed[T]]]): Rep[CostedArray[T]] = {
    new CostedArrayCtor[T](arr)
  }
  def unmkCostedArray[T](p: Rep[Costed[Array[T]]]) = p.elem.asInstanceOf[Elem[_]] match {
    case _: CostedArrayElem[T] @unchecked =>
      Some((p.asRep[CostedArray[T]].arr))
    case _ =>
      None
  }

  object ConcreteCostedBuilderMethods {
  }

  object ConcreteCostedBuilderCompanionMethods {
  }

  def mkConcreteCostedBuilder
    (): Rep[ConcreteCostedBuilder] = {
    new ConcreteCostedBuilderCtor()
  }
  def unmkConcreteCostedBuilder(p: Rep[CostedBuilder]) = p.elem.asInstanceOf[Elem[_]] match {
    case _: ConcreteCostedBuilderElem @unchecked =>
      Some(())
    case _ =>
      None
  }
}

object ConcreteCostsModule extends scalan.ModuleInfo("scalan.collection", "ConcreteCosts")
}

trait ConcreteCostsModule extends scalan.collection.impl.ConcreteCostsDefs {self: Library =>}
